# 关于`memset()`赋值

## 1. 原理 
`int`在内存中占用$4$个字节，众所周知，每个字节是 $8$ bits，所以`int`有$32$位。`memset()` 的作用就是把`int`的每个字节都复制为`memset()`的参数。
例如：
```cpp
int a;
memset(&a, 0x3f, sizeof(a));
```
`0x3f`转换为二进制是`111111`,  所以`a`的每一个字节就变成了`00111111`(注意每一个字节有$8$bits),整个`a`就变成`00111111 00111111 00111111 00111111`(中间用空格分开方便观察，其实是没有空格的)。十进制为$1061109567$

## 2. $16$ 进制与`memset()`的关系

我们经常使用$16$进制作为`memset()`的参数，$16 = 2 ^ {4}$，所以$16$进制的两位刚好就是$1$个字节，在C语言中，可以直接用`0x`前缀来表示$16$进制，所以用$16$进制非常方便。例如`0x3`表示`0011`,`0xf`表示`1111`，所以`0x3f`就表示`00111111`。

## 3. 用`memset()`赋值
常见的赋值有：最大值，最小值， $0$ ， $-1$ 。
- $0$ 和 $-1$ 可以直接用他们本身作为`memset()`的参数。因为四个`00000000`还是 $0$ ，四个`11111111`还是 $-1$ 。值得注意的是`0xffffffff == -1`， `0xff == 255`，所以也可以用`255`或者`0xff`作为参数赋值 $-1$ 。
- 最大值可以用`0x7f7f7f7f`赋值，每一个字节都是`0x7f`即`01111111`，值得注意的是`0x7f7f7f7f == 2139062143` 非常接近 `INT_MAX == 2147483647`了。所以我们经常用`0x3f3f3f3f == 1061109567`来赋值，这个数既大于$1e9$，又不会爆`int`。
- 最小值显然是一个负数，那么最高位(符号位)就必须是 $1$ ，我们想要一个类似`-0x3f3f3f3f`，即`-1 * (00111111001111110011111100111111)`一样的数作为最小值，根据规则，把`00111111001111110011111100111111`取反，变成`11000000110000001100000011000000`，加一，`11000000110000001100000011000001`,这就是负的`0x3f3f3f3f`,但是用 $16$ 进制并不能通过`memset()`表示这个数，所以我们可以稍加更改，把它变成`11000000110000001100000011000000`就可以用`0xc0 == 192`表示这个数了，这个数的大小是`-1061109568`,作为最小值非常合适。
